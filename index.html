<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Powder Crown Downhill Prototype</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      --slot-min: 70px;
      --slot-gap: 8px;
    }
    body.night-skiing {
      background: #0b1220;
      color: #e5e7eb;
    }
    body.night-skiing .panel {
      background: #111827;
      color: #e5e7eb;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
    }
    body.night-skiing .card {
      background: #1f2937;
      color: #e5e7eb;
    }
    body.night-skiing .tag {
      background: #1f2937;
      color: #e5e7eb;
    }
    body.night-skiing .slot {
      background: #1f2937;
    }
    body.night-skiing .slot.occupied {
      background: #3b2b1c;
      border-color: #f2994a;
    }
    body.night-skiing .slot .token {
      background: #111827;
      border-color: #e5e7eb;
      color: #e5e7eb;
    }
    body.night-skiing .card-label {
      color: #f9fafb;
    }
    body.night-skiing .mode-overlay {
      background: rgba(10, 15, 30, 0.92);
    }
    body.night-skiing .mode-card {
      background: #111827;
      color: #e5e7eb;
    }
    body.night-skiing .legend span {
      color: #e5e7eb;
    }
    body.night-skiing .footer-note {
      color: #94a3b8;
    }
    body {
      margin: 0;
      background: #f4f6fb;
      color: #1e2430;
    }
    .loading-screen {
      position: fixed;
      inset: 0;
      background: #000000;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      opacity: 1;
      transition: opacity 1s ease, background-color 0.8s ease;
    }
    .loading-screen.fade-out {
      opacity: 0;
      pointer-events: none;
    }
    .loading-screen.white-out {
      background: #ffffff;
    }
    .loading-emoji {
      font-size: clamp(48px, 9vw, 96px);
      opacity: 0;
      transition: opacity 0.6s ease;
      letter-spacing: 8px;
    }
    .loading-emoji.visible {
      opacity: 1;
    }
    .snowstorm {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      opacity: 0;
      transition: opacity 0.6s ease;
    }
    .snowstorm.active {
      opacity: 1;
    }
    .snowflake {
      position: absolute;
      top: -10vh;
      font-size: 20px;
      animation: snow-fall linear infinite;
      opacity: 0.85;
    }
    @keyframes snow-fall {
      0% {
        transform: translateY(-10vh);
      }
      100% {
        transform: translateY(110vh);
      }
    }
    .mode-overlay {
      position: fixed;
      inset: 0;
      background: rgba(13, 59, 102, 0.88);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 24px;
    }
    .mode-card {
      max-width: 720px;
      width: 100%;
      background: white;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
      display: grid;
      gap: 16px;
    }
    .mode-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }
    .mode-option {
      border: 2px solid #dfe6f2;
      border-radius: 12px;
      padding: 12px;
      display: grid;
      gap: 6px;
      background: #f7f9fd;
      text-align: left;
    }
    .mode-option.disabled {
      opacity: 0.5;
      filter: grayscale(0.4);
    }
    .mode-option button {
      width: 100%;
    }
    .closed-sign {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: #f3d9a4;
      color: #7b4f00;
      font-size: 12px;
      font-weight: 700;
    }
    .auto-modes {
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }
    .auto-modes .auto-grid {
      display: grid;
      gap: 6px;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
    }
    .auto-modes button {
      border-radius: 10px;
      font-size: 12px;
      padding: 6px 8px;
    }
    .auto-modes button.active {
      border-color: #1f8f4d;
      box-shadow: 0 0 0 2px rgba(31, 143, 77, 0.2);
    }
    .auto-speed {
      display: grid;
      gap: 6px;
    }
    .auto-speed .speed-grid {
      display: grid;
      gap: 6px;
      grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
    }
    main {
      padding: 24px;
      display: grid;
      gap: 20px;
      grid-template-columns: minmax(280px, 1fr) minmax(320px, 360px);
    }
    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
      }
    }
    @media (max-width: 600px) {
      :root {
        --slot-min: 58px;
        --slot-gap: 6px;
      }
      main {
        padding: 16px;
      }
    }
    .panel {
      background: white;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
    }
    .mountain-panel {
      position: relative;
      overflow: hidden;
      background: linear-gradient(180deg, rgba(224, 239, 255, 0.45), rgba(255, 255, 255, 0.95));
    }
    .mountain-panel::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 8% 8%, rgba(86, 155, 220, 0.45), transparent 38%),
        radial-gradient(circle at 92% 6%, rgba(90, 164, 228, 0.4), transparent 36%),
        linear-gradient(140deg, rgba(235, 245, 255, 0.8), rgba(255, 255, 255, 0.1) 55%),
        linear-gradient(220deg, rgba(220, 235, 250, 0.55), rgba(255, 255, 255, 0.1) 50%);
      opacity: 0.65;
      pointer-events: none;
    }
    .mountain-panel::after {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 45% 52%, rgba(90, 140, 60, 0.45), transparent 28%),
        radial-gradient(circle at 50% 56%, rgba(100, 150, 70, 0.35), transparent 30%),
        radial-gradient(circle at 35% 66%, rgba(100, 150, 70, 0.35), transparent 30%),
        radial-gradient(circle at 65% 68%, rgba(100, 150, 70, 0.35), transparent 30%),
        radial-gradient(circle at 25% 78%, rgba(100, 150, 70, 0.4), transparent 30%),
        radial-gradient(circle at 75% 78%, rgba(100, 150, 70, 0.4), transparent 30%),
        radial-gradient(circle at 20% 88%, rgba(100, 150, 70, 0.45), transparent 28%),
        radial-gradient(circle at 80% 88%, rgba(100, 150, 70, 0.45), transparent 28%);
      opacity: 0.5;
      pointer-events: none;
      mix-blend-mode: multiply;
    }
    .mountain-panel > * {
      position: relative;
      z-index: 1;
    }
    .mountain {
      display: grid;
      gap: var(--slot-gap);
      width: 100%;
    }
    .row {
      display: grid;
      gap: var(--slot-gap);
      justify-content: center;
    }
    .slot {
      background: #eef1f8;
      border: 2px solid transparent;
      border-radius: 12px;
      padding: 10px;
      min-width: 70px;
      min-height: 70px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      font-size: 14px;
      text-align: center;
      cursor: pointer;
      transition: transform 0.1s ease, border 0.2s ease;
      position: relative;
    }
    .slot:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }
    .slot.highlight {
      border-color: #2f80ed;
      box-shadow: 0 0 0 3px rgba(47, 128, 237, 0.2);
    }
    .slot.occupied {
      background: #fdebd2;
      border-color: #f2994a;
    }
    .slot.current {
      border-color: #27ae60;
      box-shadow: 0 0 0 3px rgba(39, 174, 96, 0.2);
    }
    .slot .unknown-badge {
      position: absolute;
      top: 6px;
      left: 6px;
      font-size: 12px;
      opacity: 0.7;
    }
    .slot .token {
      position: absolute;
      top: -12px;
      right: -12px;
      width: 36px;
      height: 44px;
      border-radius: 12px;
      background: #ffffff;
      border: 2px solid #1e2430;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      color: #1e2430;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.12);
      pointer-events: none;
    }
    .slot .token.fork {
      top: auto;
      right: auto;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
    }
    .slot .token.fork-2 {
      top: auto;
      right: auto;
      bottom: -26px;
      left: 50%;
      transform: translateX(-50%);
    }
    .slot .token.fork-3 {
      top: auto;
      right: auto;
      bottom: -30px;
      left: 50%;
      transform: translateX(-50%);
    }
    .slot .token.fork-4 {
      top: auto;
      right: auto;
      bottom: -34px;
      left: 50%;
      transform: translateX(-50%);
    }
    .slot .token .token-suit {
      font-size: 14px;
      margin-top: -2px;
    }
    .slot .token .token-rank {
      font-size: 15px;
      line-height: 1;
    }
    .slot .coords {
      font-size: 11px;
      opacity: 0.6;
    }
    .hide-coords .coords {
      display: none;
    }
    .card-label {
      color: #111827;
      font-weight: 600;
    }
    .result-badge {
      font-size: 13px;
      margin-left: 4px;
    }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      background: #eef1f8;
    }
    .queue-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .mountain-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .mountain-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .mode-button {
      background: #111827;
    }
    .mode-button:hover {
      background: #1f2937;
    }
    .mountain-actions .active {
      border: 2px solid #38bdf8;
    }
    .actions {
      display: grid;
      gap: 8px;
    }
    button {
      border: none;
      border-radius: 8px;
      padding: 10px 14px;
      background: #2f80ed;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    button:hover {
      background: #1c66c5;
    }
    button.secondary {
      background: #f2f4f8;
      color: #1e2430;
    }
    button.secondary:hover {
      background: #e0e5ef;
    }
    .status {
      font-size: 14px;
      line-height: 1.4;
    }
    .pile {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(48px, 1fr));
      gap: 6px;
      margin-top: 8px;
    }
    .card {
      background: #f8f9fd;
      border-radius: 8px;
      padding: 6px;
      text-align: center;
      font-size: 13px;
    }
    .card.active {
      border: 2px solid #27ae60;
      box-shadow: 0 0 0 2px rgba(39, 174, 96, 0.2);
    }
    .card.used {
      opacity: 0.4;
    }
    .legend {
      display: grid;
      gap: 6px;
      font-size: 13px;
    }
    .legend span {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .footer-note {
      font-size: 12px;
      opacity: 0.7;
      margin-top: 8px;
    }
    footer {
      padding: 12px 24px 24px;
      text-align: center;
      font-size: 13px;
      color: #4a5568;
    }
    .debug-footer {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 6px;
      font-size: 12px;
      color: #5b677a;
    }
    .score-modal {
      position: fixed;
      inset: 0;
      z-index: 25;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.65);
    }
    .score-modal.active {
      display: flex;
    }
    .score-modal .modal-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 24px;
      width: min(520px, 92vw);
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.3);
      position: relative;
      z-index: 2;
      display: grid;
      gap: 12px;
    }
    .score-modal .score-hero {
      font-size: clamp(28px, 5vw, 40px);
      font-weight: 700;
      text-align: center;
    }
    .score-modal .best-run {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      font-size: 18px;
      font-weight: 600;
    }
    .score-modal .best-run .best-icon {
      font-size: 32px;
    }
    .bonus-counts {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 6px;
      text-align: center;
      font-size: 14px;
    }
    .score-modal .modal-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .score-modal .snowstorm {
      opacity: 0.5;
    }
    .emoji-rain {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 15;
    }
    .emoji-drop {
      position: absolute;
      top: -10vh;
      font-size: 22px;
      animation: snow-fall linear infinite;
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div id="loadingScreen" class="loading-screen" aria-live="polite">
    <div id="loadingEmoji" class="loading-emoji">‚ùÑÔ∏è</div>
    <div id="snowstorm" class="snowstorm"></div>
  </div>
  <div id="scoreModal" class="score-modal" aria-live="polite">
    <div class="snowstorm" aria-hidden="true"></div>
    <div class="modal-card">
      <h2>Run Summary</h2>
      <div id="currentScoreHero" class="score-hero"></div>
      <div id="bestRunHero" class="best-run"></div>
      <div id="scoreSummary"></div>
      <div id="bonusCounts" class="bonus-counts"></div>
      <div id="todayHighScore" class="status"></div>
      <div id="allTimeHighScore" class="status"></div>
      <div class="modal-actions">
        <button id="modalPlayAgain">Play again</button>
        <button id="modalMode" class="secondary">Mode</button>
      </div>
    </div>
  </div>
  <div id="emojiRain" class="emoji-rain" aria-hidden="true"></div>
  <main>
    <section class="panel mountain-panel">
      <div class="mountain-header">
        <h2>Powder Crown Downhill Ski Resort</h2>
        <div class="mountain-actions">
          <button id="modeButton" class="mode-button">Mode</button>
          <button id="playAgainButton" class="secondary">Play again</button>
          <button id="nightSkiingButton" class="secondary">Night skiing</button>
          <button id="fullAutoButton" class="secondary">Full auto</button>
        </div>
      </div>
      <div id="mountain" class="mountain"></div>
      <div class="auto-modes" id="autoModes">
        <div class="footer-note">Auto modes</div>
        <div class="auto-grid"></div>
        <div id="autoModeStatus" class="footer-note"></div>
        <div class="auto-speed">
          <div class="footer-note">Auto speed</div>
          <div class="speed-grid"></div>
        </div>
      </div>
    </section>
    <section class="panel">
      <h2>Run Controls</h2>
      <div class="status" id="status"></div>
      <div class="actions" id="actions"></div>
      <h3>Active Skier</h3>
      <div id="activeSkier" class="tag"></div>
      <div class="queue-header">
        <h3>Skier Queue</h3>
        <div id="crowdCounter" class="tag"></div>
      </div>
      <div id="bonusTracker" class="status"></div>
      <div id="skierQueue" class="pile"></div>
      <h3>Collected Conditions</h3>
      <div id="collectedPile" class="pile"></div>
      <div id="score" class="status"></div>
      <h3>Scoreboard</h3>
      <div id="scoreHistory" class="status"></div>
      <h3>Decks</h3>
      <div class="status" id="deckStatus"></div>
      <h3>Difficulty Legend</h3>
      <div class="legend" id="legend"></div>
    </section>
  </main>
  <footer>
    Prototype v0.3 ‚Äî single-player Party Mode (mouse or touch controls)
    <div class="debug-footer">
      <span>Debug overlay shows (row, idx).</span>
      <button id="toggleDebug" type="button" class="secondary">Show debug</button>
    </div>
  </footer>
  <div id="modeOverlay" class="mode-overlay">
    <div class="mode-card">
      <h2>Select a Game Mode</h2>
      <p>Choose how you want to ski today. More modes are on the way!</p>
      <div class="mode-grid">
        <div class="mode-option">
          <strong>Free-Play (Single Run)</strong>
          <span class="footer-note">One quick run with the current queue of skiers.</span>
          <button id="startFreePlay">Start Free-Play</button>
        </div>
        <div class="mode-option">
          <strong>Full Crowd (Single Player)</strong>
          <span class="footer-note">Play through all 32 skiers and recycle memories.</span>
          <button id="startFullCrowd">Start Full Crowd</button>
        </div>
        <div class="mode-option disabled">
          <strong>Multiplayer (2-4)</strong>
          <span class="footer-note">Take turns on the shared mountain.</span>
          <span class="closed-sign">‚õ∑Ô∏è Temporary Closed</span>
          <button disabled>Temporarily Closed</button>
        </div>
      </div>
      <button id="returnToGame" class="secondary" style="display: none;">Return to current game</button>
    </div>
  </div>
  <script>
    const SYMBOLS = [
      { key: "GREEN", label: "Green Circle", icon: "üü¢", difficultyRank: 1, suit: "CLUBS" },
      { key: "BLUE", label: "Blue Square", icon: "üü¶", difficultyRank: 2, suit: "SPADES" },
      { key: "BLACK", label: "Black Diamond", icon: "‚óÜ", difficultyRank: 3, suit: "HEARTS" },
      { key: "DOUBLE_BLACK", label: "Double Black", icon: "‚óÜ‚óÜ", difficultyRank: 4, suit: "DIAMONDS" }
    ];
    const SKIER_RANKS = ["A", "J", "Q", "K"];
    const CONDITION_RANKS = [2, 3, 4, 5, 6, 7, 8, 9, 10];
    const ROW_SIZES = [1, 2, 3, 4, 5];

    const state = {
      cards: {},
      crowdDeck: [],
      cloudDeck: [],
      players: [],
      mountain: [],
      activePlayerId: "P1",
      activeRun: null,
      awaitingStartChoice: false,
      gameEnded: false,
      message: "",
      scoreHistory: [],
      lastRunScore: null,
      memoriesPile: [],
      mode: null,
      gameStarted: false,
      autoMode: null,
      autoSpeed: "ONE_X",
      autoRunning: false,
      bestRun: null,
      todayHighScore: 0,
      allTimeHighScore: 0,
      nightSkiing: false,
      fullAuto: false,
      fullAutoLoopRunning: false,
      fullAutoGames: 0,
      fullAutoTimeoutId: null,
      loadingDismissed: false,
      usedCrowdCount: 0,
      skierCounter: 0
    };

    const BONUS_EMOJIS = {
      1: "üå≠",
      2: "üçî",
      3: "üç∫",
      4: "üç¶"
    };

    const BONUS_TARGETS = {
      "üå≠": 4,
      "üçî": 3,
      "üç∫": 2,
      "üç¶": 1
    };
    const AUTO_MODES = [
      { key: "MATCH", label: "Match Mode" },
      { key: "DISCOVER", label: "Discover Mode" },
      { key: "EASY", label: "Easy Mode" },
      { key: "HUNGRY", label: "Hungry Mode" },
      { key: "THIRSTY", label: "Thirsty Mode" },
      { key: "BREW", label: "Beer Brew Mode" }
    ];
    const AUTO_SPEEDS = [
      { key: "ONE_X", label: "1x", delay: 250 },
      { key: "HALF_X", label: "0.5x", delay: 1000 },
      { key: "INSTANT", label: "Instant", delay: 0 }
    ];

    const TOTAL_CROWD = 32;

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function buildDecks() {
      let idCounter = 1;
      const cards = [];
      for (let deck = 0; deck < 2; deck += 1) {
        for (const symbol of SYMBOLS) {
          for (const rank of [...SKIER_RANKS, ...CONDITION_RANKS]) {
            const type = SKIER_RANKS.includes(rank) ? "SKIER" : "CONDITION";
            const riderType = type === "SKIER" ? (deck === 0 ? "SKIER" : "SNOWBOARDER") : null;
            const card = {
              id: `C${idCounter}`,
              type,
              rank,
              symbol: symbol.key,
              difficultyRank: symbol.difficultyRank,
              riderType
            };
            cards.push(card);
            idCounter += 1;
          }
        }
      }
      return cards;
    }

    function splitCrowdCloud(cards) {
      const crowd = [];
      const cloud = [];
      cards.forEach((card) => {
        if (card.type === "SKIER") {
          crowd.push(card);
        } else {
          cloud.push(card);
        }
      });
      return { crowd, cloud };
    }

    function faceShuffleCloud(cloudCards) {
      const deck = shuffle([...cloudCards]);
      const midpoint = Math.ceil(deck.length / 2);
      const firstHalf = deck.slice(0, midpoint);
      const secondHalf = deck.slice(midpoint);
      const faceUpSet = new Set(secondHalf.map((card) => card.id));
      const combined = shuffle([...firstHalf, ...secondHalf]);
      return combined.map((card) => ({ cardId: card.id, isFaceUp: faceUpSet.has(card.id) }));
    }

    function replenishCloudFromMemories() {
      if (!state.memoriesPile.length) return false;
      const memoryCards = state.memoriesPile.map((cardId) => state.cards[cardId]);
      state.memoriesPile = [];
      state.cloudDeck = faceShuffleCloud(memoryCards);
      return true;
    }

    function drawCloudCard() {
      if (!state.cloudDeck.length && state.memoriesPile.length) {
        replenishCloudFromMemories();
      }
      return state.cloudDeck.pop() || null;
    }

    function slotId(row, idx) {
      let id = 0;
      for (let r = 1; r < row; r += 1) {
        id += ROW_SIZES[r - 1];
      }
      return id + idx;
    }

    function rowIdxFromSlotId(id) {
      let remaining = id;
      for (let r = 1; r <= ROW_SIZES.length; r += 1) {
        const size = ROW_SIZES[r - 1];
        if (remaining < size) {
          return { row: r, idx: remaining };
        }
        remaining -= size;
      }
      return { row: 5, idx: 0 };
    }

    const downNeighbors = (() => {
      const neighbors = Array(15).fill(null).map(() => []);
      ROW_SIZES.forEach((size, rowIndex) => {
        const row = rowIndex + 1;
        for (let idx = 0; idx < size; idx += 1) {
          const current = slotId(row, idx);
          if (row < 5) {
            const left = slotId(row + 1, idx);
            const right = slotId(row + 1, idx + 1);
            neighbors[current].push(left, right);
          }
        }
      });
      return neighbors;
    })();

    function dealMountain() {
      const mountain = [];
      ROW_SIZES.forEach((size, rowIndex) => {
        for (let idx = 0; idx < size; idx += 1) {
          const draw = drawCloudCard();
          mountain.push({
            row: rowIndex + 1,
            idx,
            conditionCardId: draw?.cardId || null,
            isFaceUp: draw?.isFaceUp || false,
            occupiedBySkierId: null,
            lastResult: null,
            missCount: 0,
            bonusEmoji: null
          });
        }
      });
      return mountain;
    }

    function dealSkiers(player, count = 4) {
      for (let i = 0; i < count; i += 1) {
        const card = state.crowdDeck.pop();
        if (!card) return;
        state.skierCounter += 1;
        const skierId = `S${state.skierCounter}`;
        state.cards[skierId] = {
          id: skierId,
          ownerId: player.id,
          cardId: card.id,
          status: "available",
          pausedPos: null,
          piggybackRole: "none",
          linkedSkierId: null
        };
        player.skierQueue.push(skierId);
      }
    }

    function getSymbol(card) {
      return SYMBOLS.find((symbol) => symbol.key === card.symbol);
    }

    function getCardLabel(card) {
      const symbol = getSymbol(card);
      if (card.type === "SKIER") {
        const riderIcon = card.riderType === "SNOWBOARDER" ? "üèÇ" : "‚õ∑Ô∏è";
        return `${riderIcon} ${card.rank} ${symbol.icon}`;
      }
      return `${symbol.icon} ${card.rank}`;
    }

    function getHiddenConditionLabel(card) {
      const treeCount = Math.max(1, Math.min(4, card.difficultyRank));
      return "üå≤".repeat(treeCount);
    }

    function getBonusEmoji(missCount) {
      const capped = Math.min(4, missCount);
      return BONUS_EMOJIS[capped] || null;
    }

    function getBonusValue(missCount) {
      return Math.min(4, missCount);
    }

    function getSkierTokenMarkup(skierId, variant = "") {
      if (!skierId) return "";
      const skierState = state.cards[skierId];
      const card = state.cards[skierState.cardId];
      const symbol = getSymbol(card);
      const riderIcon = card.riderType === "SNOWBOARDER" ? "üèÇ" : "‚õ∑Ô∏è";
      const variantClass = variant ? ` ${variant}` : "";
      return `<div class="token${variantClass}" aria-hidden="true">
        <div class="token-rank">${card.rank}</div>
        <div class="token-suit">${riderIcon} ${symbol.icon}</div>
      </div>`;
    }

    function getTokenVariantForRow(row) {
      if (row === 1) return "fork";
      if (row === 2) return "fork-2";
      if (row === 3) return "fork-3";
      if (row === 4) return "fork-4";
      return "";
    }

    function formatNumber(value) {
      if (!Number.isFinite(value)) return "‚àû";
      if (Math.abs(value) >= 1e12) {
        return value.toExponential(2);
      }
      return value.toLocaleString("en-US", { maximumFractionDigits: 2 });
    }

    function getCollectedPileSorted() {
      const pile = getPlayer().collectedPile;
      return [...pile].sort((a, b) => {
        const aRank = Number(state.cards[a.cardId].rank);
        const bRank = Number(state.cards[b.cardId].rank);
        return bRank - aRank;
      });
    }

    function getCollectedPileGrouped() {
      const grouped = new Map();
      getPlayer().collectedPile.forEach((entry) => {
        const key = entry.cardId;
        if (!grouped.has(key)) {
          grouped.set(key, { entry, count: 0 });
        }
        grouped.get(key).count += 1;
      });
      return [...grouped.values()].sort((a, b) => {
        const aRank = Number(state.cards[a.entry.cardId].rank);
        const bRank = Number(state.cards[b.entry.cardId].rank);
        return bRank - aRank;
      });
    }

    function getPlayer() {
      return state.players.find((player) => player.id === state.activePlayerId);
    }

    function getPausedSkier() {
      const player = getPlayer();
      return player.skierQueue.find((skierId) => state.cards[skierId].status === "paused");
    }

    function getStartSlots(mountain = state.mountain) {
      for (let row = 1; row <= 5; row += 1) {
        const candidates = mountain
          .map((slot, id) => ({ ...slot, id }))
          .filter((slot) => slot.row === row && slot.occupiedBySkierId === null);
        if (candidates.length) {
          return candidates.map((slot) => slot.id);
        }
      }
      return [];
    }

    function hasClearPath(tempOccupiedSlotId) {
      const occupied = new Set(
        state.mountain
          .map((slot, id) => ({ slot, id }))
          .filter(({ slot }) => slot.occupiedBySkierId)
          .map(({ id }) => id)
      );
      if (tempOccupiedSlotId !== null) {
        occupied.add(tempOccupiedSlotId);
      }
      const startSlots = getStartSlots(
        state.mountain.map((slot, id) => ({
          ...slot,
          occupiedBySkierId: occupied.has(id) ? "blocked" : null
        }))
      );
      const goals = new Set(
        state.mountain
          .map((slot, id) => ({ slot, id }))
          .filter(({ slot }) => slot.row === 5 && !occupied.has(id))
          .map(({ id }) => id)
      );
      const queue = [...startSlots];
      const visited = new Set(queue);
      while (queue.length) {
        const current = queue.shift();
        if (goals.has(current)) {
          return true;
        }
        downNeighbors[current].forEach((neighbor) => {
          if (!occupied.has(neighbor) && !visited.has(neighbor)) {
            visited.add(neighbor);
            queue.push(neighbor);
          }
        });
      }
      return false;
    }

    function beginGame() {
      state.gameStarted = true;
      hideScoreModal();
      const deck = buildDecks();
      deck.forEach((card) => {
        state.cards[card.id] = card;
      });
      const { crowd, cloud } = splitCrowdCloud(deck);
      state.crowdDeck = shuffle([...crowd]);
      state.cloudDeck = faceShuffleCloud(cloud);
      state.mountain = dealMountain();
      state.usedCrowdCount = 0;
      state.skierCounter = 0;
      const player = { id: "P1", skierQueue: [], collectedPile: [] };
      state.players = [player];
      dealSkiers(player, 4);
      state.activeRun = null;
      state.gameEnded = false;
      state.message = "Game ready. Start your first run!";
      state.scoreHistory = [];
      state.lastRunScore = null;
      state.memoriesPile = [];
      state.autoMode = null;
      state.autoSpeed = "ONE_X";
      state.autoRunning = false;
      state.bestRun = null;
      if (!state.allTimeHighScore) {
        state.allTimeHighScore = loadAllTimeHighScore();
      }
      updateTurn();
    }

    function updateTurn() {
      if (state.gameEnded) {
        render();
        return;
      }
      const player = getPlayer();
      const pausedSkierId = getPausedSkier();
      if (pausedSkierId) {
        const skier = state.cards[pausedSkierId];
        if (skier.pausedPos !== null) {
          state.mountain[skier.pausedPos].occupiedBySkierId = null;
        }
        skier.status = "available";
        state.activeRun = {
          playerId: player.id,
          leadSkierId: pausedSkierId,
          currentSlotId: skier.pausedPos,
          resumed: true,
          collectedScore: 0
        };
        state.message = "Resuming paused skier. Choose your next step.";
      } else if (!state.activeRun) {
        let nextSkierId = player.skierQueue.find((skierId) => state.cards[skierId].status === "available");
        if (!nextSkierId && state.mode === "FULL" && state.crowdDeck.length > 0) {
          dealSkiers(player, 4);
          nextSkierId = player.skierQueue.find((skierId) => state.cards[skierId].status === "available");
        }
      if (!nextSkierId) {
        state.message = "All skiers used. Game over!";
        state.gameEnded = true;
        showScoreModal();
        if (state.fullAuto) {
          if (state.fullAutoTimeoutId) {
            clearTimeout(state.fullAutoTimeoutId);
          }
          state.fullAutoTimeoutId = setTimeout(() => {
            state.fullAutoGames += 1;
            if (state.fullAutoGames % 2 === 0) {
              setNightSkiing(!state.nightSkiing);
            }
            beginGame();
            runFullAutoLoop();
          }, 3000);
        }
        render();
        return;
      }
        const startSlots = getStartSlots();
        state.awaitingStartChoice = true;
        if (startSlots.length === 1) {
          startRunAt(startSlots[0]);
        } else {
          state.message = "Pick a start slot to begin the run.";
        }
      }
      render();
    }

    function startRunAt(slotIdChoice) {
      const player = getPlayer();
      const nextSkierId = player.skierQueue.find((skierId) => state.cards[skierId].status === "available");
      state.activeRun = {
        playerId: player.id,
        leadSkierId: nextSkierId,
        currentSlotId: slotIdChoice,
        resumed: false,
        collectedScore: 0
      };
      state.awaitingStartChoice = false;
      resolveSlot(slotIdChoice, nextSkierId);
      state.message = "Run started. Continue downhill.";
    }

    function getNextAvailableSkierId() {
      return getPlayer().skierQueue.find((skierId) => state.cards[skierId].status === "available") || null;
    }

    function getSkierCard(skierId) {
      if (!skierId) return null;
      const skierState = state.cards[skierId];
      return state.cards[skierState.cardId];
    }

    function getCollectedCounts() {
      return getPlayer().collectedPile.reduce((acc, entry) => {
        const card = state.cards[entry.cardId];
        acc[card.rank] = (acc[card.rank] || 0) + 1;
        return acc;
      }, {});
    }

    function getSlotData(slotId) {
      const slot = state.mountain[slotId];
      const card = slot.conditionCardId ? state.cards[slot.conditionCardId] : null;
      return { slot, card };
    }

    function getBonusCounts() {
      return getPlayer().collectedPile.reduce((acc, entry) => {
        if (entry.bonusEmoji) {
          acc[entry.bonusEmoji] = (acc[entry.bonusEmoji] || 0) + 1;
        }
        return acc;
      }, {});
    }

    function scoreMatchMode(card, skierCard, rankCounts) {
      if (!card || !skierCard) return 0;
      const eligible = card.difficultyRank <= skierCard.difficultyRank;
      const matches = rankCounts[card.rank] || 0;
      const suitMatch = card.symbol === skierCard.symbol ? 1 : 0;
      const rankValue = Number(card.rank) || 0;
      const base = eligible ? 1000 : 0;
      const difficultyWeight = eligible ? 100 : 12;
      return base + card.difficultyRank * difficultyWeight + suitMatch * 40 + matches * 15 + rankValue;
    }

    function scoreDiscoverMode(card, slot) {
      if (!card) return 0;
      const hiddenBonus = slot.isFaceUp ? 0 : 500;
      return hiddenBonus + card.difficultyRank * 20 + Number(card.rank || 0);
    }

    function scoreEasyMode(card) {
      if (!card) return 0;
      const difficultyScore = (5 - card.difficultyRank) * 20;
      const rankScore = 11 - Number(card.rank || 0);
      return difficultyScore + rankScore;
    }

    function scoreHungryMode(card, slot, bonusCounts, skierCard) {
      if (!card || !slot.bonusEmoji) return 0;
      const emoji = slot.bonusEmoji;
      const targets = BONUS_TARGETS[emoji] || 0;
      const current = bonusCounts[emoji] || 0;
      const needs = Math.max(0, targets - current);
      const isQueen = skierCard?.rank === "Q";
      let priority = 0;
      if (emoji === "üå≠" && needs > 0) priority = 300;
      if (emoji === "üçî" && needs > 0) priority = Math.max(priority, 280);
      if (emoji === "üç∫") priority = Math.max(priority, isQueen ? 220 : 260);
      if (emoji === "üç¶") priority = Math.max(priority, isQueen ? 340 : 220);
      return priority + card.difficultyRank * 10;
    }

    function scoreThirstyMode(card, slot) {
      if (!card) return 0;
      const beerBonus = slot.bonusEmoji === "üç∫" ? 300 : 0;
      return beerBonus + card.difficultyRank * 10 + Number(card.rank || 0);
    }

    function scoreBrewMode(card, slot, skierCard) {
      if (!card || !skierCard) return 0;
      const eligible = card.difficultyRank <= skierCard.difficultyRank;
      const uncollectable = eligible ? 0 : 240;
      const burgerBonus = !eligible && slot.bonusEmoji === "üçî" ? 60 : 0;
      return uncollectable + burgerBonus + card.difficultyRank * 10;
    }

    function chooseAutoSlot(mode, slotIds, skierCard) {
      const rankCounts = getCollectedCounts();
      const bonusCounts = getBonusCounts();
      let best = slotIds[0];
      let bestScore = -Infinity;
      slotIds.forEach((slotId) => {
        const { slot, card } = getSlotData(slotId);
        let score = 0;
        if (mode === "MATCH") {
          score = scoreMatchMode(card, skierCard, rankCounts);
        } else if (mode === "DISCOVER") {
          score = scoreDiscoverMode(card, slot);
        } else if (mode === "EASY") {
          score = scoreEasyMode(card);
        } else if (mode === "HUNGRY") {
          score = scoreHungryMode(card, slot, bonusCounts, skierCard);
        } else if (mode === "THIRSTY") {
          score = scoreThirstyMode(card, slot);
        } else if (mode === "BREW") {
          score = scoreBrewMode(card, slot, skierCard);
        }
        if (score > bestScore) {
          bestScore = score;
          best = slotId;
        }
      });
      return best;
    }

    function wait(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function getAutoDelay() {
      const speed = AUTO_SPEEDS.find((entry) => entry.key === state.autoSpeed) || AUTO_SPEEDS[0];
      return speed.delay;
    }

    async function runAutoMode(mode) {
      if (state.gameEnded || !state.gameStarted) return;
      if (state.autoRunning) return;
      state.autoRunning = true;
      state.autoMode = mode;
      let safety = 0;
      while (safety < 50) {
        if (state.gameEnded) break;
        if (state.awaitingStartChoice) {
          const startSlots = getStartSlots();
          if (!startSlots.length) break;
          const skierCard = getSkierCard(getNextAvailableSkierId());
          const choice = chooseAutoSlot(mode, startSlots, skierCard);
          startRunAt(choice);
          if (getAutoDelay() > 0) {
            await wait(getAutoDelay());
          }
          safety += 1;
          continue;
        }
        if (!state.activeRun) break;
        const options = getMoveOptionsOrdered();
        if (!options.length) break;
        const skierCard = getSkierCard(state.activeRun.leadSkierId);
        const choice = chooseAutoSlot(mode, options, skierCard);
        moveTo(choice);
        if (getAutoDelay() > 0) {
          await wait(getAutoDelay());
        }
        safety += 1;
      }
      state.autoRunning = false;
      render();
    }

    function resolveSlot(slotId, skierId) {
      const slot = state.mountain[slotId];
      if (!slot.conditionCardId) {
        return;
      }
      if (!slot.isFaceUp) {
        slot.isFaceUp = true;
      }
      const card = state.cards[slot.conditionCardId];
      const skierCard = state.cards[state.cards[skierId].cardId];
      if (card.difficultyRank <= skierCard.difficultyRank) {
        const bonusValue = getBonusValue(slot.missCount || 0);
        const bonusEmoji = slot.bonusEmoji;
        slot.conditionCardId = null;
        slot.isFaceUp = false;
        slot.lastResult = { cardId: card.id, outcome: "collected" };
        getPlayer().collectedPile.push({
          cardId: card.id,
          bonus: bonusValue,
          bonusEmoji: slot.bonusEmoji
        });
        state.memoriesPile.push(card.id);
        slot.missCount = 0;
        slot.bonusEmoji = null;
        const run = state.activeRun;
        if (run) {
          run.collectedScore = (run.collectedScore || 0) + Number(card.rank) + bonusValue;
        }
        if (bonusEmoji) {
          spawnEmojiRain(bonusEmoji, 8);
        }
        state.message = bonusValue
          ? `Condition collected with bonus +${bonusValue}!`
          : "Condition collected!";
      } else {
        slot.lastResult = { cardId: card.id, outcome: "missed" };
        state.message = "Condition too difficult. It remains on the mountain.";
      }
    }

    function moveTo(slotId) {
      if (!state.activeRun) return;
      state.activeRun.currentSlotId = slotId;
      resolveSlot(slotId, state.activeRun.leadSkierId);
      const { row } = rowIdxFromSlotId(slotId);
      if (row === 5) {
        finishRun();
        return;
      }
      render();
    }

    function finishRun() {
      const run = state.activeRun;
      const skierState = state.cards[run.leadSkierId];
      skierState.status = "used";
      skierState.pausedPos = null;
      if (!state.bestRun || (run.collectedScore || 0) > state.bestRun.finalScore) {
        const skierCardId = state.cards[run.leadSkierId].cardId;
        state.bestRun = {
          skierId: run.leadSkierId,
          skierCardId,
          finalScore: run.collectedScore || 0
        };
      }
      state.activeRun = null;
      state.usedCrowdCount += 1;
      recordScore();
      applyMissUpgrades();
      state.message = "Run complete! Mountain is refilling.";
      refillMountain();
      updateTurn();
    }

    function applyMissUpgrades() {
      state.mountain.forEach((slot) => {
        if (slot.lastResult?.outcome === "missed" && slot.conditionCardId) {
          slot.missCount = (slot.missCount || 0) + 1;
          slot.bonusEmoji = getBonusEmoji(slot.missCount);
          slot.lastResult = null;
        }
      });
    }

    function refillMountain() {
      const emptySlots = state.mountain.filter((slot) => slot.conditionCardId === null);
      let available = state.cloudDeck.length;
      if (available < emptySlots.length && state.memoriesPile.length) {
        replenishCloudFromMemories();
        available = state.cloudDeck.length;
      }
      if (available < emptySlots.length) {
        state.gameEnded = true;
        state.message = "Cloud deck depleted. Game over!";
        render();
        return;
      }
      emptySlots.forEach((slot) => {
        const draw = drawCloudCard();
        slot.conditionCardId = draw.cardId;
        slot.isFaceUp = draw.isFaceUp;
        slot.lastResult = null;
        slot.missCount = 0;
        slot.bonusEmoji = null;
      });
    }

    function waitForGroup() {
      if (!state.activeRun) return;
      const slotId = state.activeRun.currentSlotId;
      if (!hasClearPath(slotId)) {
        state.message = "Wait blocked: no clear path for the next run.";
        render();
        return;
      }
      const skier = state.cards[state.activeRun.leadSkierId];
      skier.status = "paused";
      skier.pausedPos = slotId;
      state.mountain[slotId].occupiedBySkierId = skier.id;
      state.activeRun = null;
      state.message = "Skier paused. Next skier's turn.";
      updateTurn();
    }

    function computeScore() {
      const pile = getPlayer().collectedPile;
      const baseTotal = pile.reduce((sum, entry) => sum + Number(state.cards[entry.cardId].rank) + entry.bonus, 0);
      const counts = pile.reduce((acc, entry) => {
        const card = state.cards[entry.cardId];
        acc[card.rank] = (acc[card.rank] || 0) + 1;
        return acc;
      }, {});
      const maxCount = Math.max(0, ...Object.values(counts));
      const mult = Math.min(8, maxCount || 1);
      const finalScore = baseTotal * mult;
      const bonusCounts = pile.reduce((acc, entry) => {
        if (entry.bonusEmoji) {
          acc[entry.bonusEmoji] = (acc[entry.bonusEmoji] || 0) + 1;
        }
        return acc;
      }, {});
      const metGoals = Object.entries(BONUS_TARGETS).filter(
        ([emoji, target]) => (bonusCounts[emoji] || 0) >= target
      );
      const goalCount = metGoals.length;
      const exponent = goalCount === 0 ? 1 : goalCount + 1;
      let endDayScore = finalScore ** exponent;
      if (goalCount === Object.keys(BONUS_TARGETS).length) {
        endDayScore *= Math.PI;
      }
      return {
        baseTotal,
        mult,
        finalScore,
        endDayScore,
        counts,
        bonusCounts,
        goalCount,
        exponent
      };
    }

    function recordScore() {
      const summary = computeScore();
      state.lastRunScore = {
        ...summary,
        collected: [...getPlayer().collectedPile]
      };
      state.scoreHistory.push({ ...summary, timestamp: Date.now() });
      state.scoreHistory.sort((a, b) => b.endDayScore - a.endDayScore);
      state.scoreHistory = state.scoreHistory.slice(0, 5);
      state.todayHighScore = Math.max(state.todayHighScore || 0, summary.endDayScore || 0);
      const allTime = loadAllTimeHighScore();
      if (summary.endDayScore > allTime) {
        saveAllTimeHighScore(summary.endDayScore);
        state.allTimeHighScore = summary.endDayScore;
      } else {
        state.allTimeHighScore = allTime;
      }
    }

    function getMoveOptions() {
      if (!state.activeRun) return [];
      const { currentSlotId } = state.activeRun;
      const { row } = rowIdxFromSlotId(currentSlotId);
      if (row === 5) return [];
      return downNeighbors[currentSlotId].filter((id) => state.mountain[id].occupiedBySkierId === null);
    }

    function getMoveOptionsOrdered() {
      if (!state.activeRun) return [];
      const { currentSlotId } = state.activeRun;
      const neighbors = downNeighbors[currentSlotId];
      return neighbors.filter((id) => state.mountain[id].occupiedBySkierId === null);
    }

    function render() {
      renderMountain();
      renderSidebar();
      const fullAutoButton = document.getElementById("fullAutoButton");
      if (fullAutoButton) {
        fullAutoButton.classList.toggle("active", state.fullAuto);
        fullAutoButton.textContent = state.fullAuto ? "Stop auto" : "Full auto";
      }
    }

    function renderMountain() {
      const mountainEl = document.getElementById("mountain");
      mountainEl.innerHTML = "";
      ROW_SIZES.forEach((size, rowIndex) => {
        const rowEl = document.createElement("div");
        rowEl.className = "row";
        rowEl.style.gridTemplateColumns = `repeat(${size}, minmax(var(--slot-min), 1fr))`;
        for (let idx = 0; idx < size; idx += 1) {
          const id = slotId(rowIndex + 1, idx);
          const slot = state.mountain[id];
          const card = slot.conditionCardId ? state.cards[slot.conditionCardId] : null;
          const button = document.createElement("button");
          button.className = "slot";
          const isHighlighted = isSelectableSlot(id);
          if (isHighlighted) {
            button.classList.add("highlight");
          }
          if (slot.occupiedBySkierId) {
            button.classList.add("occupied");
          }
          if (state.activeRun && state.activeRun.currentSlotId === id) {
            button.classList.add("current");
          }
          button.disabled = !isHighlighted;
          let label = "Empty";
          if (card) {
            const bonusEmoji = slot.isFaceUp && slot.bonusEmoji ? ` ${slot.bonusEmoji}` : "";
            label = slot.isFaceUp ? `${getCardLabel(card)}${bonusEmoji}` : getHiddenConditionLabel(card);
            if (slot.lastResult && slot.lastResult.outcome === "missed" && slot.isFaceUp) {
              label = `${label} <span class="result-badge">‚ùå</span>`;
            }
          } else if (slot.lastResult) {
            const lastCard = state.cards[slot.lastResult.cardId];
            const resultIcon = slot.lastResult.outcome === "collected" ? "‚úÖ" : "‚ùå";
            label = `${getCardLabel(lastCard)} <span class="result-badge">${resultIcon}</span>`;
          }
          const tokenMarkup =
            state.activeRun && state.activeRun.currentSlotId === id
              ? getSkierTokenMarkup(state.activeRun.leadSkierId, getTokenVariantForRow(slot.row))
              : "";
          button.innerHTML = `
            <div class="card-label">${label}</div>
            <div class="coords">(${slot.row}, ${slot.idx})</div>
            ${slot.occupiedBySkierId ? `<div class="coords">Paused</div>` : ""}
            ${card && !slot.isFaceUp ? `<div class="unknown-badge">‚ùî</div>` : ""}
            ${tokenMarkup}
          `;
          button.addEventListener("click", () => handleSlotClick(id));
          rowEl.appendChild(button);
        }
        mountainEl.appendChild(rowEl);
      });
    }

    function isSelectableSlot(id) {
      if (state.gameEnded) return false;
      if (state.awaitingStartChoice) {
        return getStartSlots().includes(id);
      }
      const moveOptions = getMoveOptions();
      return moveOptions.includes(id);
    }

    function handleSlotClick(id) {
      if (state.awaitingStartChoice) {
        startRunAt(id);
        return;
      }
      if (getMoveOptions().includes(id)) {
        moveTo(id);
      }
    }

    function handleKeyMove(event) {
      if (!state.gameStarted || state.gameEnded) return;
      if (state.awaitingStartChoice) {
        const startSlots = getStartSlots();
        if (!startSlots.length) return;
        if (event.key === "ArrowLeft") {
          startRunAt(startSlots[0]);
        } else if (event.key === "ArrowRight") {
          startRunAt(startSlots[startSlots.length - 1]);
        }
        return;
      }
      if (!state.activeRun) return;
      const options = getMoveOptionsOrdered();
      if (!options.length) return;
      if (event.key === "ArrowLeft" && options[0]) {
        moveTo(options[0]);
      } else if (event.key === "ArrowRight") {
        moveTo(options[options.length - 1]);
      }
    }

    function renderSidebar() {
      const statusEl = document.getElementById("status");
      const actionsEl = document.getElementById("actions");
      const activeSkierEl = document.getElementById("activeSkier");
      const autoModesEl = document.getElementById("autoModes");
      const queueEl = document.getElementById("skierQueue");
      const collectedEl = document.getElementById("collectedPile");
      const scoreEl = document.getElementById("score");
      const scoreHistoryEl = document.getElementById("scoreHistory");
      const deckStatusEl = document.getElementById("deckStatus");
      const crowdCounterEl = document.getElementById("crowdCounter");
      const legendEl = document.getElementById("legend");

      statusEl.textContent = state.message;
      actionsEl.innerHTML = "";
      if (state.activeRun) {
        const skierState = state.cards[state.activeRun.leadSkierId];
        const card = state.cards[skierState.cardId];
        activeSkierEl.textContent = `Lead: ${getCardLabel(card)} (${getSymbol(card).label})`;
      } else {
        activeSkierEl.textContent = "No active skier";
      }

      const autoGrid = autoModesEl.querySelector(".auto-grid");
      autoGrid.innerHTML = "";
      AUTO_MODES.forEach((mode) => {
        const button = document.createElement("button");
        button.type = "button";
        button.textContent = mode.label;
        if (state.autoMode === mode.key) {
          button.classList.add("active");
        }
        button.addEventListener("click", () => runAutoMode(mode.key));
        autoGrid.appendChild(button);
      });
      const autoModeStatus = document.getElementById("autoModeStatus");
      if (autoModeStatus) {
        const activeLabel = AUTO_MODES.find((mode) => mode.key === state.autoMode)?.label || "None";
        autoModeStatus.textContent = `Active auto mode: ${activeLabel}`;
      }
      const speedGrid = autoModesEl.querySelector(".speed-grid");
      speedGrid.innerHTML = "";
      AUTO_SPEEDS.forEach((speed) => {
        const button = document.createElement("button");
        button.type = "button";
        button.textContent = speed.label;
        if (state.autoSpeed === speed.key) {
          button.classList.add("active");
        }
        button.addEventListener("click", () => {
          state.autoSpeed = speed.key;
          render();
        });
        speedGrid.appendChild(button);
      });

      queueEl.innerHTML = "";
      const activeSkierId = state.activeRun?.leadSkierId || null;
      const queueSorted = [...getPlayer().skierQueue].sort((a, b) => {
        const aUsed = state.cards[a].status === "used";
        const bUsed = state.cards[b].status === "used";
        if (aUsed === bUsed) return 0;
        return aUsed ? 1 : -1;
      });
      queueSorted.forEach((skierId) => {
        const skierState = state.cards[skierId];
        const card = state.cards[skierState.cardId];
        const div = document.createElement("div");
        div.className = "card";
        if (skierId === activeSkierId) {
          div.classList.add("active");
        }
        if (skierState.status === "used") {
          div.classList.add("used");
        }
        const statusLabel = skierId === activeSkierId ? "active" : skierState.status;
        div.textContent = `${getCardLabel(card)} - ${statusLabel}`;
        queueEl.appendChild(div);
      });

      collectedEl.innerHTML = "";
      getCollectedPileGrouped().forEach(({ entry, count }) => {
        const card = state.cards[entry.cardId];
        const div = document.createElement("div");
        div.className = "card";
        const countLabel = count > 1 ? ` √ó${count}` : "";
        div.textContent = `${getCardLabel(card)}${entry.bonusEmoji ? ` ${entry.bonusEmoji}` : ""}${countLabel}`;
        collectedEl.appendChild(div);
      });

      const { baseTotal, mult, finalScore, endDayScore, counts, bonusCounts, exponent, goalCount } = computeScore();
      const histogram = Object.entries(counts)
        .map(([rank, count]) => `${rank}: ${count}`)
        .join(", ");
      const bonusSummary = Object.entries(BONUS_TARGETS)
        .map(([emoji, target]) => `${emoji} ${bonusCounts[emoji] || 0}/${target}`)
        .join(" ¬∑ ");
      scoreEl.innerHTML = `Base total: <strong>${formatNumber(baseTotal)}</strong><br />
        Multiplier: <strong>${mult}√ó</strong><br />
        Final score: <strong>${formatNumber(finalScore)}</strong><br />
        End of day score: <strong>${formatNumber(endDayScore)}</strong><br />
        <span class="footer-note">Exponent: ${exponent} (goals met: ${goalCount})</span><br />
        <span class="footer-note">Ranks collected: ${histogram || "None"}</span>`;
      const bonusTrackerEl = document.getElementById("bonusTracker");
      bonusTrackerEl.innerHTML = `<span class="footer-note">Bonus goals: ${bonusSummary}</span>`;

      const lastRun = state.lastRunScore;
      const topScores = state.scoreHistory;
      const formatCollected = (entries) =>
        entries.length
          ? entries
              .map((entry) => {
                const card = state.cards[entry.cardId];
                return `${getCardLabel(card)}${entry.bonusEmoji ? ` ${entry.bonusEmoji}` : ""}`;
              })
              .join(", ")
          : "None";
      const lastRunText = lastRun
        ? `Last run ‚Äî base ${formatNumber(lastRun.baseTotal)}, mult ${lastRun.mult}√ó, final ${formatNumber(
            lastRun.finalScore
          )}, end-day ${formatNumber(lastRun.endDayScore)}<br />
        <span class="footer-note">Collected: ${formatCollected(lastRun.collected)}</span><br />`
        : "Last run ‚Äî none yet";
      const topList = topScores.length
        ? `<ol>${topScores
            .map(
              (entry) =>
                `<li>${formatNumber(entry.endDayScore)} (final ${formatNumber(entry.finalScore)}, ${entry.exponent}x)</li>`
            )
            .join("")}</ol>`
        : "<p>No top scores yet.</p>";
      scoreHistoryEl.innerHTML = `${lastRunText}${topList}`;

      const todayLine = `Today‚Äôs High Score: <strong>${formatNumber(state.todayHighScore)}</strong>`;
      const allTimeLine = `All-time High Score (local): <strong>${formatNumber(state.allTimeHighScore)}</strong>`;
      scoreHistoryEl.innerHTML += `<p>${todayLine}<br />${allTimeLine}</p>`;

      deckStatusEl.innerHTML = `Crowd deck remaining: ${state.crowdDeck.length}<br />
        Cloud deck remaining: ${state.cloudDeck.length}<br />
        Memories pile: ${state.memoriesPile.length}`;

      legendEl.innerHTML = "";
      SYMBOLS.forEach((symbol) => {
        const row = document.createElement("span");
        row.textContent = `${symbol.icon} ${symbol.label} (Rank ${symbol.difficultyRank})`;
        legendEl.appendChild(row);
      });

      const totalCrowd = TOTAL_CROWD;
      crowdCounterEl.textContent = `${state.usedCrowdCount}/${totalCrowd}`;
    }

    function showModeOverlay(show) {
      const overlay = document.getElementById("modeOverlay");
      const returnButton = document.getElementById("returnToGame");
      if (returnButton) {
        returnButton.style.display = show && state.gameStarted ? "inline-flex" : "none";
      }
      overlay.style.display = show ? "flex" : "none";
    }

    function setNightSkiing(enabled) {
      state.nightSkiing = enabled;
      document.body.classList.toggle("night-skiing", enabled);
      const nightButton = document.getElementById("nightSkiingButton");
      if (nightButton) {
        nightButton.textContent = enabled ? "Day skiing" : "Night skiing";
      }
    }

    function getRandomAutoMode() {
      return AUTO_MODES[Math.floor(Math.random() * AUTO_MODES.length)].key;
    }

    async function runFullAutoLoop() {
      if (state.fullAutoLoopRunning) return;
      state.fullAutoLoopRunning = true;
      while (state.fullAuto) {
        if (state.gameEnded) {
          await wait(200);
          continue;
        }
        if (state.autoRunning) {
          await wait(100);
          continue;
        }
        if (state.awaitingStartChoice || state.activeRun) {
          await runAutoMode(getRandomAutoMode());
        } else {
          await wait(100);
        }
      }
      state.fullAutoLoopRunning = false;
    }

    function startFullAuto() {
      state.fullAuto = true;
      state.autoSpeed = "ONE_X";
      state.fullAutoGames = 0;
      state.mode = "FULL";
      beginGame();
      runFullAutoLoop();
    }

    function stopFullAuto() {
      state.fullAuto = false;
      if (state.fullAutoTimeoutId) {
        clearTimeout(state.fullAutoTimeoutId);
        state.fullAutoTimeoutId = null;
      }
    }

    function showScoreModal() {
      const modal = document.getElementById("scoreModal");
      const summaryEl = document.getElementById("scoreSummary");
      const heroEl = document.getElementById("currentScoreHero");
      const bestRunEl = document.getElementById("bestRunHero");
      const bonusCountsEl = document.getElementById("bonusCounts");
      const todayEl = document.getElementById("todayHighScore");
      const allTimeEl = document.getElementById("allTimeHighScore");
      const summary = computeScore();
      const bestRun = state.bestRun;
      const bestRunLabel = bestRun ? getCardLabel(state.cards[bestRun.skierCardId]) : "None yet";
      summaryEl.innerHTML = `
        <div class="status">Base total: <strong>${formatNumber(summary.baseTotal)}</strong></div>
        <div class="status">Multiplier: <strong>${summary.mult}√ó</strong></div>
        <div class="status">Final score: <strong>${formatNumber(summary.finalScore)}</strong></div>
        <div class="status">End of day score: <strong>${formatNumber(summary.endDayScore)}</strong></div>
        <div class="status">Exponent: <strong>${summary.exponent}</strong></div>
      `;
      heroEl.textContent = `Current score: ${formatNumber(summary.endDayScore)}`;
      bestRunEl.innerHTML = bestRun
        ? `<div class="best-icon">${bestRunLabel}</div><div>Best run: ${formatNumber(bestRun.finalScore)}</div>`
        : `<div class="best-icon">‚Äî</div><div>Best run: None yet</div>`;
      const bonusCounts = summary.bonusCounts || {};
      bonusCountsEl.innerHTML = Object.entries(BONUS_TARGETS)
        .map(([emoji, target]) => `${emoji} ${bonusCounts[emoji] || 0}/${target}`)
        .join(" ");
      todayEl.innerHTML = `Today‚Äôs High Score: <strong>${formatNumber(state.todayHighScore)}</strong>`;
      allTimeEl.innerHTML = `All-time High Score (local): <strong>${formatNumber(state.allTimeHighScore)}</strong>`;
      const snowstorm = modal.querySelector(".snowstorm");
      if (snowstorm) {
        createSnowstorm(snowstorm);
        snowstorm.classList.add("active");
      }
      modal.classList.add("active");
    }

    function hideScoreModal() {
      const modal = document.getElementById("scoreModal");
      modal.classList.remove("active");
    }

    function spawnEmojiRain(emoji, count = 6) {
      const rain = document.getElementById("emojiRain");
      for (let i = 0; i < count; i += 1) {
        const drop = document.createElement("span");
        drop.className = "emoji-drop";
        drop.textContent = emoji;
        drop.style.left = `${Math.random() * 100}%`;
        drop.style.animationDuration = `${1.6 + Math.random() * 1.8}s`;
        drop.style.fontSize = `${18 + Math.random() * 18}px`;
        rain.appendChild(drop);
        setTimeout(() => {
          drop.remove();
        }, 3000);
      }
    }

    function loadAllTimeHighScore() {
      const stored = localStorage.getItem("powderCrownHighScore");
      const value = stored ? Number(stored) : 0;
      return Number.isFinite(value) ? value : 0;
    }

    function saveAllTimeHighScore(value) {
      localStorage.setItem("powderCrownHighScore", String(value));
    }

    function createSnowstorm(target = document.getElementById("snowstorm"), count = 60) {
      const snowstorm = target;
      snowstorm.innerHTML = "";
      const symbols = ["‚ùÖ", "‚ùÜ", "‚ùÖ"];
      const colors = ["#ffffff", "#d7ecff", "#c1dbf7"];
      for (let i = 0; i < count; i += 1) {
        const flake = document.createElement("span");
        flake.className = "snowflake";
        flake.textContent = symbols[Math.floor(Math.random() * symbols.length)];
        flake.style.left = `${Math.random() * 100}%`;
        flake.style.color = colors[Math.floor(Math.random() * colors.length)];
        flake.style.animationDuration = `${2 + Math.random() * 3}s`;
        flake.style.animationDelay = `${Math.random() * 1.5}s`;
        flake.style.fontSize = `${14 + Math.random() * 18}px`;
        snowstorm.appendChild(flake);
      }
    }

    function finalizeLoading() {
      const loadingScreen = document.getElementById("loadingScreen");
      if (state.loadingDismissed) return;
      state.loadingDismissed = true;
      loadingScreen.classList.add("fade-out");
      setTimeout(() => {
        loadingScreen.style.display = "none";
      }, 600);
    }

    function startLoadingSequence() {
      const loadingScreen = document.getElementById("loadingScreen");
      const loadingEmoji = document.getElementById("loadingEmoji");
      const snowstorm = document.getElementById("snowstorm");
      const sequence = ["‚ùÑÔ∏è", "üëë", "üèîÔ∏è", "‚õ∑Ô∏è"];
      let step = 0;
      showModeOverlay(false);

      const showStep = () => {
        if (state.loadingDismissed) return;
        if (step >= sequence.length) {
          createSnowstorm(snowstorm, 140);
          snowstorm.classList.add("active");
          setTimeout(() => {
            if (state.loadingDismissed) return;
            loadingScreen.classList.add("white-out");
            setTimeout(() => {
              if (state.loadingDismissed) return;
              loadingScreen.style.display = "none";
              showModeOverlay(true);
            }, 700);
          }, 600);
          return;
        }
        loadingEmoji.textContent = sequence[step];
        loadingEmoji.classList.add("visible");
        setTimeout(() => {
          loadingEmoji.classList.remove("visible");
          step += 1;
          setTimeout(showStep, 300);
        }, 700);
      };

      showStep();
    }

    function startMode(mode) {
      state.mode = mode;
      showModeOverlay(false);
      beginGame();
    }

    window.startMode = startMode;

    document.getElementById("startFreePlay").addEventListener("click", () => startMode("FREE"));
    document.getElementById("startFullCrowd").addEventListener("click", () => startMode("FULL"));
    document.getElementById("modeButton").addEventListener("click", () => showModeOverlay(true));
    document.getElementById("playAgainButton").addEventListener("click", () => beginGame());
    document.getElementById("fullAutoButton").addEventListener("click", () => {
      if (state.fullAuto) {
        stopFullAuto();
      } else {
        startFullAuto();
      }
      render();
    });
    document.getElementById("modalPlayAgain").addEventListener("click", () => {
      hideScoreModal();
      beginGame();
    });
    document.getElementById("modalMode").addEventListener("click", () => {
      hideScoreModal();
      showModeOverlay(true);
    });
    document.getElementById("returnToGame").addEventListener("click", () => showModeOverlay(false));
    const toggleDebugButton = document.getElementById("toggleDebug");
    document.body.classList.add("hide-coords");
    toggleDebugButton.addEventListener("click", () => {
      document.body.classList.toggle("hide-coords");
      toggleDebugButton.textContent = document.body.classList.contains("hide-coords")
        ? "Show debug"
        : "Hide debug";
    });
    const loadingScreen = document.getElementById("loadingScreen");
    const loadingEmoji = document.getElementById("loadingEmoji");
    loadingScreen.addEventListener("pointerdown", (event) => {
      if (state.loadingDismissed) return;
      if (event.target === loadingEmoji) {
        finalizeLoading();
        setNightSkiing(false);
        state.fullAutoGames = 0;
        startFullAuto();
        return;
      }
      finalizeLoading();
      showModeOverlay(true);
    });
    document.addEventListener("keydown", (event) => {
      if (!state.loadingDismissed) {
        finalizeLoading();
        showModeOverlay(true);
        return;
      }
      handleKeyMove(event);
    });
    startLoadingSequence();
    state.allTimeHighScore = loadAllTimeHighScore();
    const nightSkiingButton = document.getElementById("nightSkiingButton");
    nightSkiingButton.addEventListener("click", () => setNightSkiing(!state.nightSkiing));
  </script>
</body>
</html>
